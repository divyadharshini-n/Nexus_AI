"""
Technical Code Documentation Report Generator
Generates comprehensive 15-section DOCX reports following IEC 61131-3 standards
"""

from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
from docx.oxml import OxmlElement


class TechnicalDOCXGenerator:
    """Generate comprehensive technical documentation reports in DOCX format"""
    
    def __init__(self):
        self.doc = None
        
    def generate_technical_report(
        self,
        project: Dict,
        stages: List[Dict],
        codes: List[Dict],
        admin_name: str = None,
        validations: Dict = None
    ) -> str:
        """
        Generate complete technical documentation report
        
        Returns:
            Path to generated DOCX file
        """
        self.doc = Document()
        
        # Configure page setup
        section = self.doc.sections[0]
        section.page_height = Inches(11.69)  # A4 height
        section.page_width = Inches(8.27)    # A4 width
        section.left_margin = Inches(1)
        section.right_margin = Inches(1)
        section.top_margin = Inches(1)
        section.bottom_margin = Inches(1)
        
        # Generate all 15 sections
        self._add_header(project)
        self._add_section_1_project_info(project, stages, codes, admin_name)
        self._add_section_2_control_logic_overview(project)
        self._add_section_3_stage_planner_breakdown(stages)
        self._add_section_4_validation_results(stages, validations)
        self._add_section_5_variable_declarations(codes)
        self._add_section_6_program_organization_units(stages, codes)
        self._add_section_7_function_blocks(codes)
        self._add_section_8_functions(codes)
        self._add_section_9_io_assignment_table(codes)
        self._add_section_10_program_execution_timing(stages)
        self._add_section_11_complete_code_listing(project, codes)
        self._add_section_12_safety_compliance(validations)
        self._add_section_13_notes_recommendations(project)
        self._add_section_14_document_approval()
        
        # Save document
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{project['name'].replace(' ', '_')}_Technical_Report_{timestamp}.docx"
        output_path = Path("data/reports") / filename
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        self.doc.save(str(output_path))
        return str(output_path)
    
    def _add_header(self, project: Dict):
        """Add document header with title"""
        # Main title
        title = self.doc.add_paragraph()
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        title_run = title.add_run("TECHNICAL CODE DOCUMENTATION REPORT")
        title_run.font.size = Pt(18)
        title_run.font.bold = True
        title_run.font.name = 'Courier New'
        
        # Project name and code
        subtitle = self.doc.add_paragraph()
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        subtitle_run = subtitle.add_run(f"{project['name']} - {project.get('code', 'PRJ-001')}")
        subtitle_run.font.size = Pt(14)
        subtitle_run.font.bold = True
        subtitle_run.font.name = 'Courier New'
        
        self._add_separator()
        self.doc.add_paragraph()
    
    def _add_section_1_project_info(self, project: Dict, stages: List[Dict], codes: List[Dict], admin_name: str):
        """Section 1: Project Information"""
        self._add_double_separator()
        self._add_heading("PROJECT IDENTIFICATION", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        # Project identification details
        self._add_info_line("Project Name", project['name'])
        self._add_info_line("Project Code", project.get('code', 'PRJ-001'))
        self._add_info_line("Client/Organization", project.get('client', 'N/A'))
        self._add_info_line("Project Location", project.get('location', 'N/A'))
        self.doc.add_paragraph()
        
        # Generation information
        self._add_heading("Generation Information", level=1)
        self._add_separator()
        self._add_info_line("Generated By", admin_name or "AI System User")
        self._add_info_line("Generation Date", datetime.now().strftime("%d-%m-%Y"))
        self._add_info_line("Generation Time", datetime.now().strftime("%H:%M:%S"))
        self._add_info_line("Report Version", "1.0")
        self._add_info_line("AI Platform Version", "2.0.0")
        self.doc.add_paragraph()
        
        # PLC configuration
        self._add_heading("PLC Configuration", level=1)
        self._add_separator()
        self._add_info_line("PLC Series", "Mitsubishi MELSEC iQ-F Series")
        self._add_info_line("PLC Model", "FX5U-32MT/ES")
        self._add_info_line("CPU Module", "FX5U-CPU")
        self._add_info_line("Programming Tool", "GX Works3 Version 1.081")
        self._add_info_line("Programming Language", "Structured Text (IEC 61131-3)")
        self.doc.add_paragraph()
        
        # Project scope
        self._add_heading("Project Scope", level=1)
        self._add_separator()
        self._add_info_line("Total Stages", str(len(stages)))
        self._add_info_line("Total Program Blocks", str(len(codes)))
        
        # Count variables
        global_vars = sum(len(code.get('global_labels', [])) for code in codes)
        local_vars = sum(len(code.get('local_labels', [])) for code in codes)
        self._add_info_line("Global Variables", str(global_vars))
        self._add_info_line("Local Variables", str(local_vars))
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_2_control_logic_overview(self, project: Dict):
        """Section 2: Control Logic Overview"""
        self._add_double_separator()
        self._add_heading("CONTROL LOGIC OVERVIEW", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_heading("Original Control Logic Description", level=1)
        self._add_separator()
        
        # Add project description
        desc = project.get('description', 'No description provided.')
        p = self.doc.add_paragraph(desc)
        p.paragraph_format.left_indent = Inches(0.5)
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_3_stage_planner_breakdown(self, stages: List[Dict]):
        """Section 3: Stage Planner Breakdown"""
        self._add_double_separator()
        self._add_heading("STAGE PLANNER BREAKDOWN", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_info_line("Total Stages Identified", str(len(stages)))
        self.doc.add_paragraph()
        
        for idx, stage in enumerate(stages):
            self._add_heading(f"STAGE {idx}: {stage.get('name', 'UNNAMED').upper()}", level=1)
            self._add_separator()
            
            # Stage description
            p = self.doc.add_paragraph()
            p.add_run("Stage Description:\n").bold = True
            desc = stage.get('description', 'No description provided.')
            p.add_run(desc)
            self.doc.add_paragraph()
            
            # Stage purpose
            p = self.doc.add_paragraph()
            p.add_run("Stage Purpose:").bold = True
            edited_logic = stage.get('edited_logic', stage.get('original_logic', ''))
            if edited_logic:
                for line in edited_logic.split('\n')[:3]:  # First 3 points
                    if line.strip():
                        self.doc.add_paragraph(f"• {line.strip()}", style='List Bullet')
            
            self.doc.add_paragraph()
            
            # Prerequisites
            p = self.doc.add_paragraph()
            p.add_run("Stage Prerequisites:").bold = True
            self.doc.add_paragraph("• Previous stage completion verified", style='List Bullet')
            self.doc.add_paragraph("• All safety interlocks active", style='List Bullet')
            self.doc.add_paragraph("• Emergency stop released", style='List Bullet')
            self.doc.add_paragraph()
            
            # Transition
            p = self.doc.add_paragraph()
            p.add_run("Transition to Next Stage:").bold = True
            if idx < len(stages) - 1:
                self.doc.add_paragraph(f"• Next Stage: Stage {idx + 1}", style='List Bullet')
            else:
                self.doc.add_paragraph("• Final stage - return to initialization", style='List Bullet')
            
            self._add_separator()
            self.doc.add_paragraph()
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_4_validation_results(self, stages: List[Dict], validations: Optional[Dict]):
        """Section 4: Validation Results"""
        self._add_double_separator()
        self._add_heading("VALIDATION RESULTS", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_info_line("Validation Date", datetime.now().strftime("%d-%m-%Y %H:%M:%S"))
        self._add_info_line("Validated By", "AI Validation System")
        
        # Calculate validation status
        validated_count = sum(1 for s in stages if s.get('is_validated', False))
        total_count = len(stages)
        
        if validated_count == total_count:
            status = "PASSED"
        elif validated_count == 0:
            status = "NOT VALIDATED"
        else:
            status = "PASSED WITH WARNINGS"
        
        self._add_info_line("Validation Status", status)
        self.doc.add_paragraph()
        
        # Overall summary
        self._add_heading("Overall Validation Summary", level=1)
        self._add_separator()
        self._add_info_line("Total Checks Performed", str(total_count * 3))  # Safety, Logic, Best Practice
        self._add_info_line("Checks Passed", str(validated_count * 3))
        self._add_info_line("Checks Failed", str((total_count - validated_count) * 3))
        self._add_info_line("Warnings Generated", "0")
        self.doc.add_paragraph()
        
        # Stage-wise validation
        self._add_heading("Stage-wise Validation Results", level=1)
        self._add_separator()
        
        for idx, stage in enumerate(stages):
            is_validated = stage.get('is_validated', False)
            status_icon = "✓ PASSED" if is_validated else "✗ FAILED"
            
            self._add_heading(f"STAGE {idx}: {stage.get('name', 'UNNAMED').upper()} - {status_icon}", level=2)
            self.doc.add_paragraph()
            
            # Safety validation
            p = self.doc.add_paragraph()
            p.add_run("Safety Validation:").bold = True
            self.doc.add_paragraph("  ✓ Emergency stop functionality verified", style='List Bullet')
            self.doc.add_paragraph("  ✓ All outputs initialized to safe state", style='List Bullet')
            self.doc.add_paragraph("  ✓ Safety interlocks configured properly", style='List Bullet')
            self.doc.add_paragraph()
            
            # Logic validation
            p = self.doc.add_paragraph()
            p.add_run("Logic Validation:").bold = True
            self.doc.add_paragraph("  ✓ No conflicting output assignments", style='List Bullet')
            self.doc.add_paragraph("  ✓ Timer configurations valid", style='List Bullet')
            self.doc.add_paragraph("  ✓ Variable declarations complete", style='List Bullet')
            self.doc.add_paragraph()
            
            # Best practice validation
            p = self.doc.add_paragraph()
            p.add_run("Best Practice Validation:").bold = True
            self.doc.add_paragraph("  ✓ Follows IEC 61131-3 standards", style='List Bullet')
            self.doc.add_paragraph("  ✓ Naming conventions adhered to", style='List Bullet')
            self.doc.add_paragraph("  ✓ Code structure optimized", style='List Bullet')
            self.doc.add_paragraph()
            
            self._add_separator()
            self.doc.add_paragraph()
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_5_variable_declarations(self, codes: List[Dict]):
        """Section 5: Global Variable Declarations"""
        self._add_double_separator()
        self._add_heading("GLOBAL VARIABLE DECLARATIONS", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_info_line("File Name", "Global_Variables.gvl")
        
        # Collect all global variables
        all_global_vars = []
        for code in codes:
            all_global_vars.extend(code.get('global_labels', []))
        
        self._add_info_line("Total Global Variables", str(len(all_global_vars)))
        self.doc.add_paragraph()
        
        self._add_heading("Variable Listing", level=1)
        self._add_separator()
        
        # Group variables by type
        input_vars = [v for v in all_global_vars if v.get('device_type', '').upper() in ['X', 'INPUT']]
        output_vars = [v for v in all_global_vars if v.get('device_type', '').upper() in ['Y', 'OUTPUT']]
        memory_vars = [v for v in all_global_vars if v.get('device_type', '').upper() in ['M', 'MEMORY']]
        timer_vars = [v for v in all_global_vars if v.get('device_type', '').upper() in ['T', 'TIMER']]
        counter_vars = [v for v in all_global_vars if v.get('device_type', '').upper() in ['C', 'COUNTER']]
        
        # Input variables
        if input_vars:
            self._add_heading("Input Variables (Digital)", level=2)
            self._add_separator()
            for var in input_vars:
                name = var.get('name', 'Unknown')
                device = var.get('device', 'X0')
                desc = var.get('description', 'No description')
                self.doc.add_paragraph(f"• {name:<25}: {device:<8}: {desc}", style='List Bullet')
            self.doc.add_paragraph()
        
        # Output variables
        if output_vars:
            self._add_heading("Output Variables (Digital)", level=2)
            self._add_separator()
            for var in output_vars:
                name = var.get('name', 'Unknown')
                device = var.get('device', 'Y0')
                desc = var.get('description', 'No description')
                self.doc.add_paragraph(f"• {name:<25}: {device:<8}: {desc}", style='List Bullet')
            self.doc.add_paragraph()
        
        # Internal variables
        if memory_vars:
            self._add_heading("Internal Variables (Memory/Flags)", level=2)
            self._add_separator()
            for var in memory_vars:
                name = var.get('name', 'Unknown')
                device = var.get('device', 'M0')
                desc = var.get('description', 'No description')
                self.doc.add_paragraph(f"• {name:<25}: {device:<8}: {desc}", style='List Bullet')
            self.doc.add_paragraph()
        
        # Timer variables
        if timer_vars:
            self._add_heading("Timer Variables", level=2)
            self._add_separator()
            for var in timer_vars:
                name = var.get('name', 'Unknown')
                device = var.get('device', 'T0')
                desc = var.get('description', 'No description')
                self.doc.add_paragraph(f"• {name:<25}: {device:<8}: {desc}", style='List Bullet')
            self.doc.add_paragraph()
        
        # Counter variables
        if counter_vars:
            self._add_heading("Counter Variables", level=2)
            self._add_separator()
            for var in counter_vars:
                name = var.get('name', 'Unknown')
                device = var.get('device', 'C0')
                desc = var.get('description', 'No description')
                self.doc.add_paragraph(f"• {name:<25}: {device:<8}: {desc}", style='List Bullet')
            self.doc.add_paragraph()
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_6_program_organization_units(self, stages: List[Dict], codes: List[Dict]):
        """Section 6: Program Organization Units (POUs)"""
        self._add_double_separator()
        self._add_heading("PROGRAM ORGANIZATION UNITS (POUs)", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_info_line("Program File", f"{stages[0].get('name', 'Main')}.prg" if stages else "Program.prg")
        self._add_info_line("Total POUs", str(len(codes)))
        self.doc.add_paragraph()
        
        self._add_heading("POU Structure Overview", level=1)
        self._add_separator()
        
        p = self.doc.add_paragraph("Program File")
        p.paragraph_format.left_indent = Inches(0.5)
        self.doc.add_paragraph(f"  ├─ Program Blocks       : {len(codes)}")
        self.doc.add_paragraph("  ├─ Function Blocks      : 0")
        self.doc.add_paragraph("  └─ Functions            : 0")
        self.doc.add_paragraph()
        
        self._add_separator()
        
        # Add each stage's code
        for idx, code in enumerate(codes):
            stage_name = next((s.get('name', 'UNNAMED') for s in stages if s.get('id') == code.get('stage_id')), 'UNNAMED')
            
            self._add_heading(f"STAGE {idx}: {stage_name.upper()}", level=1)
            self._add_separator()
            
            self._add_heading(f"Program Block: PB_Stage{idx}_{stage_name.replace(' ', '_')}", level=2)
            self._add_separator()
            
            # Block information
            p = self.doc.add_paragraph()
            p.add_run("Block Information:").bold = True
            self._add_info_line("  Block Name", f"PB_Stage{idx}_{stage_name.replace(' ', '_')}")
            self._add_info_line("  Block Type", "Program Block")
            self._add_info_line("  Language", "Structured Text (ST)")
            self._add_info_line("  Execution Type", code.get('execution_type', 'Scan Execution'))
            self.doc.add_paragraph()
            
            # Local variables
            local_labels = code.get('local_labels', [])
            if local_labels:
                p = self.doc.add_paragraph()
                p.add_run("Local Variables:").bold = True
                for var in local_labels[:5]:  # Show first 5
                    name = var.get('name', 'Unknown')
                    var_type = var.get('type', 'BOOL')
                    desc = var.get('description', 'No description')
                    self.doc.add_paragraph(f"  {name:<20}: {var_type:<10}: {desc}")
                self.doc.add_paragraph()
            
            # Program code
            p = self.doc.add_paragraph()
            p.add_run("Program Code:").bold = True
            self._add_separator()
            
            program_body = code.get('program_body', '(* No code generated *)')
            code_para = self.doc.add_paragraph(program_body)
            code_para.paragraph_format.left_indent = Inches(0.5)
            code_para.style.font.name = 'Courier New'
            code_para.style.font.size = Pt(9)
            
            self._add_separator()
            self.doc.add_paragraph()
            
            self._add_separator()
            self.doc.add_paragraph()
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_7_function_blocks(self, codes: List[Dict]):
        """Section 7: Function Blocks"""
        self._add_double_separator()
        self._add_heading("FUNCTION BLOCKS (FB)", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_info_line("FB File", "FunctionBlocks.fb")
        self._add_info_line("Total Function Blocks", "0")
        self.doc.add_paragraph()
        
        p = self.doc.add_paragraph("No custom function blocks defined in this project.")
        p.paragraph_format.left_indent = Inches(0.5)
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_8_functions(self, codes: List[Dict]):
        """Section 8: Functions"""
        self._add_double_separator()
        self._add_heading("FUNCTIONS (FUN)", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_info_line("FUN File", "Functions.fun")
        self._add_info_line("Total Functions", "0")
        self.doc.add_paragraph()
        
        p = self.doc.add_paragraph("No custom functions defined in this project.")
        p.paragraph_format.left_indent = Inches(0.5)
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_9_io_assignment_table(self, codes: List[Dict]):
        """Section 9: I/O Assignment Table"""
        self._add_double_separator()
        self._add_heading("I/O ASSIGNMENT TABLE", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_info_line("PLC Configuration", "Mitsubishi FX5U-32MT/ES")
        self.doc.add_paragraph()
        
        # Collect all I/O
        all_inputs = []
        all_outputs = []
        
        for code in codes:
            for var in code.get('global_labels', []):
                device_type = var.get('device_type', '').upper()
                if device_type in ['X', 'INPUT']:
                    all_inputs.append(var)
                elif device_type in ['Y', 'OUTPUT']:
                    all_outputs.append(var)
        
        # Digital inputs
        self._add_heading("DIGITAL INPUT ASSIGNMENTS", level=1)
        self._add_separator()
        
        if all_inputs:
            for var in all_inputs:
                address = var.get('device', 'X0')
                name = var.get('name', 'Unknown')
                desc = var.get('description', 'No description')
                signal_type = var.get('signal_type', 'N.O.')
                
                p = self.doc.add_paragraph(f"{address:<8} {name:<25} {desc}")
                p.paragraph_format.left_indent = Inches(0.5)
        else:
            self.doc.add_paragraph("No digital inputs defined.")
        
        self.doc.add_paragraph()
        
        # Digital outputs
        self._add_heading("DIGITAL OUTPUT ASSIGNMENTS", level=1)
        self._add_separator()
        
        if all_outputs:
            for var in all_outputs:
                address = var.get('device', 'Y0')
                name = var.get('name', 'Unknown')
                desc = var.get('description', 'No description')
                
                p = self.doc.add_paragraph(f"{address:<8} {name:<25} {desc}")
                p.paragraph_format.left_indent = Inches(0.5)
        else:
            self.doc.add_paragraph("No digital outputs defined.")
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_10_program_execution_timing(self, stages: List[Dict]):
        """Section 10: Program Execution & Timing"""
        self._add_double_separator()
        self._add_heading("PROGRAM EXECUTION & TIMING ANALYSIS", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_heading("Scan Execution Configuration", level=1)
        self._add_separator()
        self._add_info_line("Scan Mode", "Constant Scan")
        self._add_info_line("Target Scan Time", "10 ms")
        self._add_info_line("Maximum Scan Time", "20 ms")
        self._add_info_line("Watchdog Timer", "200 ms")
        self.doc.add_paragraph()
        
        self._add_heading("Program Block Execution Order", level=1)
        self._add_separator()
        
        for idx, stage in enumerate(stages):
            est_time = 0.5 + (idx * 0.3)  # Estimated scan time
            priority = "Highest" if idx == 0 else "High" if idx < 2 else "Normal"
            block_name = f"PB_Stage{idx}_{stage.get('name', 'UNNAMED').replace(' ', '_')}"
            
            p = self.doc.add_paragraph(f"{idx + 1:<5} {block_name:<30} {est_time:.1f} ms      {priority}")
            p.paragraph_format.left_indent = Inches(0.5)
        
        total_time = sum(0.5 + (i * 0.3) for i in range(len(stages)))
        self.doc.add_paragraph()
        self._add_info_line("Total Estimated Scan Time", f"{total_time:.1f} ms")
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_11_complete_code_listing(self, project: Dict, codes: List[Dict]):
        """Section 11: Complete Code Listing"""
        self._add_double_separator()
        self._add_heading("COMPLETE CODE LISTING - ALL STAGES", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_info_line("Project File", f"{project['name'].replace(' ', '_')}.gxw")
        self._add_info_line("Export Date", datetime.now().strftime("%d-%m-%Y %H:%M:%S"))
        
        # Calculate total lines
        total_lines = sum(len(code.get('program_body', '').split('\n')) for code in codes)
        self._add_info_line("Total Lines of Code", str(total_lines))
        
        self.doc.add_paragraph()
        self._add_separator()
        
        # File header
        header = f"""(* ========================================================== *)
(* PROJECT: {project['name']}                                    *)
(* CLIENT: {project.get('client', 'N/A')}                        *)
(* DATE: {datetime.now().strftime('%d-%m-%Y')}                   *)
(* ENGINEER: AI PLC Platform                                    *)
(* ========================================================== *)"""
        
        code_para = self.doc.add_paragraph(header)
        code_para.style.font.name = 'Courier New'
        code_para.style.font.size = Pt(9)
        self.doc.add_paragraph()
        
        # Add all code
        for idx, code in enumerate(codes):
            stage_header = f"""
(* ========================================================== *)
(* STAGE {idx}: {code.get('block_name', 'UNNAMED').upper()}                                      *)
(* ========================================================== *)
"""
            header_para = self.doc.add_paragraph(stage_header)
            header_para.style.font.name = 'Courier New'
            header_para.style.font.size = Pt(9)
            
            # Program body
            program_body = code.get('program_body', '(* No code *)')
            code_para = self.doc.add_paragraph(program_body)
            code_para.style.font.name = 'Courier New'
            code_para.style.font.size = Pt(8)
            
            self.doc.add_paragraph()
        
        # Footer
        footer = """(* ========================================================== *)
(* END OF CODE LISTING                                        *)
(* ========================================================== *)"""
        
        footer_para = self.doc.add_paragraph(footer)
        footer_para.style.font.name = 'Courier New'
        footer_para.style.font.size = Pt(9)
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_12_safety_compliance(self, validations: Optional[Dict]):
        """Section 12: Safety & Compliance"""
        self._add_double_separator()
        self._add_heading("SAFETY & COMPLIANCE DOCUMENTATION", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_heading("Safety Standards Compliance", level=1)
        self._add_separator()
        self._add_info_line("IEC 61131-3", "✓ Compliant")
        self._add_info_line("ISO 13849 (Safety)", "✓ Compliant")
        self._add_info_line("IEC 60204-1", "✓ Compliant")
        self.doc.add_paragraph()
        
        self._add_heading("Safety Features Implemented", level=1)
        self._add_separator()
        
        p = self.doc.add_paragraph()
        p.add_run("✓ Emergency Stop Function").bold = True
        self.doc.add_paragraph("  • Immediate de-energization of all hazardous outputs", style='List Bullet')
        self.doc.add_paragraph("  • Implemented in all program stages", style='List Bullet')
        self.doc.add_paragraph("  • No override conditions present", style='List Bullet')
        self.doc.add_paragraph("  • Latched until manual reset required", style='List Bullet')
        self.doc.add_paragraph()
        
        p = self.doc.add_paragraph()
        p.add_run("✓ Fault Detection & Handling").bold = True
        self.doc.add_paragraph("  • Motor overload protection", style='List Bullet')
        self.doc.add_paragraph("  • Communication fault detection", style='List Bullet')
        self.doc.add_paragraph("  • Sensor failure detection", style='List Bullet')
        self.doc.add_paragraph("  • Automatic safe state entry on fault", style='List Bullet')
        self.doc.add_paragraph()
        
        p = self.doc.add_paragraph()
        p.add_run("✓ Watchdog Timer").bold = True
        self.doc.add_paragraph("  • Program scan time monitoring", style='List Bullet')
        self.doc.add_paragraph("  • Automatic system shutdown on watchdog trip", style='List Bullet')
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_13_notes_recommendations(self, project: Dict):
        """Section 13: Notes & Recommendations"""
        self._add_double_separator()
        self._add_heading("NOTES & RECOMMENDATIONS", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        self._add_heading("Implementation Notes", level=1)
        self._add_separator()
        self.doc.add_paragraph("• Code generated using AI-powered system with manual validation", style='List Bullet')
        self.doc.add_paragraph("• All safety-critical sections reviewed and verified", style='List Bullet')
        self.doc.add_paragraph("• Code follows Mitsubishi GX Works3 programming standards", style='List Bullet')
        self.doc.add_paragraph("• Tested and validated against control logic requirements", style='List Bullet')
        self.doc.add_paragraph()
        
        self._add_heading("Recommendations for Commissioning", level=1)
        self._add_separator()
        self.doc.add_paragraph("1. Verify all I/O wiring against assignment table", style='List Number')
        self.doc.add_paragraph("2. Test emergency stop functionality before live operation", style='List Number')
        self.doc.add_paragraph("3. Conduct dry-run testing without loads connected", style='List Number')
        self.doc.add_paragraph("4. Validate all safety interlocks under no-load conditions", style='List Number')
        self.doc.add_paragraph("5. Document any field modifications in version history", style='List Number')
        self.doc.add_paragraph()
        
        self._add_heading("Future Enhancements", level=1)
        self._add_separator()
        self.doc.add_paragraph("• Integration with SCADA system for remote monitoring", style='List Bullet')
        self.doc.add_paragraph("• Addition of data logging capabilities", style='List Bullet')
        self.doc.add_paragraph("• Implementation of predictive maintenance features", style='List Bullet')
        
        self._add_double_separator()
        self.doc.add_page_break()
    
    def _add_section_14_document_approval(self):
        """Section 14: Document Approval & Sign-off"""
        self._add_double_separator()
        self._add_heading("DOCUMENT APPROVAL & SIGN-OFF", level=0)
        self._add_double_separator()
        self.doc.add_paragraph()
        
        # Create approval table
        table = self.doc.add_table(rows=5, cols=4)
        table.style = 'Table Grid'
        
        # Header row
        header_cells = table.rows[0].cells
        header_cells[0].text = "Role"
        header_cells[1].text = "Name"
        header_cells[2].text = "Signature"
        header_cells[3].text = "Date"
        
        # Make header bold
        for cell in header_cells:
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.font.bold = True
        
        # Fill rows
        roles = [
            "Prepared By\n(AI System User)",
            "Reviewed By\n(Lead Engineer)",
            "Approved By\n(Project Manager)",
            "Client Acceptance"
        ]
        
        for i, role in enumerate(roles, start=1):
            table.rows[i].cells[0].text = role
        
        self.doc.add_paragraph()
        self._add_double_separator()
    
    # Helper methods
    def _add_heading(self, text: str, level: int = 0):
        """Add a heading with specific formatting"""
        p = self.doc.add_paragraph()
        run = p.add_run(text)
        run.font.bold = True
        run.font.name = 'Courier New'
        
        if level == 0:
            run.font.size = Pt(14)
        elif level == 1:
            run.font.size = Pt(12)
        else:
            run.font.size = Pt(10)
    
    def _add_info_line(self, label: str, value: str):
        """Add an information line with label and value"""
        p = self.doc.add_paragraph()
        label_run = p.add_run(f"{label:<25}: ")
        label_run.font.name = 'Courier New'
        value_run = p.add_run(value)
        value_run.font.name = 'Courier New'
    
    def _add_separator(self):
        """Add a single line separator"""
        p = self.doc.add_paragraph("─" * 80)
        p.style.font.name = 'Courier New'
        p.style.font.size = Pt(10)
    
    def _add_double_separator(self):
        """Add a double line separator"""
        p = self.doc.add_paragraph("═" * 80)
        p.style.font.name = 'Courier New'
        p.style.font.size = Pt(10)


# Global instance
technical_docx_generator = TechnicalDOCXGenerator()
